package usecase

import (
	"context"
	"errors"
	"time"

	"electronics-store/internal/domain/models"
	"electronics-store/internal/repository"
)

var (
	ErrPaymentNotFound = errors.New("payment not found")
	ErrInvalidOrder    = errors.New("invalid order")
)

type PaymentRequest struct {
	Method          string
	Amount          float64
	Currency        string
	TransactionID   string
	GatewayResponse string
}

type PaymentUsecase interface {
	CreatePayment(ctx context.Context, orderResourceID string, userID uint, req PaymentRequest) (*models.Payment, error)
	GetPaymentByID(ctx context.Context, id uint) (*models.Payment, error)
	GetPaymentByResourceID(ctx context.Context, resourceID string) (*models.Payment, error)
	GetPaymentsByOrderID(ctx context.Context, orderID uint) ([]*models.Payment, error)
	UpdatePayment(ctx context.Context, payment *models.Payment) error
}

type paymentUsecase struct {
	paymentRepo repository.PaymentRepository
	orderRepo   repository.OrderRepository
}

func NewPaymentUsecase(paymentRepo repository.PaymentRepository, orderRepo repository.OrderRepository) PaymentUsecase {
	return &paymentUsecase{
		paymentRepo: paymentRepo,
		orderRepo:   orderRepo,
	}
}

func (u *paymentUsecase) CreatePayment(ctx context.Context, orderResourceID string, userID uint, req PaymentRequest) (*models.Payment, error) {
	// Get order by resource ID
	order, err := u.orderRepo.GetByResourceID(ctx, orderResourceID)
	if err != nil {
		return nil, errors.New("failed to fetch order: " + err.Error())
	}
	if order == nil {
		return nil, ErrInvalidOrder
	}

	// Verify order belongs to user
	if order.UserID != userID {
		return nil, errors.New("unauthorized: order does not belong to user")
	}

	// Verify payment amount matches order total (within small tolerance for rounding)
	if req.Amount < order.Total*0.99 || req.Amount > order.Total*1.01 {
		return nil, errors.New("payment amount does not match order total")
	}

	// Create payment record - ResourceID will be auto-generated by BeforeCreate hook
	now := time.Now()
	payment := &models.Payment{
		OrderID:         order.ID,
		Method:          req.Method,
		Amount:          req.Amount,
		Currency:        req.Currency,
		Status:          "completed", // Payment status in payments table
		TransactionID:   req.TransactionID,
		GatewayResponse: req.GatewayResponse,
		ProcessedAt:     &now,
	}

	// Create payment in database - this will trigger BeforeCreate hook to generate ResourceID
	err = u.paymentRepo.Create(ctx, payment)
	if err != nil {
		return nil, errors.New("failed to create payment record in database: " + err.Error())
	}

	// Update order payment status to "paid"
	order.PaymentStatus = "paid"
	err = u.orderRepo.Update(ctx, order)
	if err != nil {
		// Payment was created successfully, but order update failed
		// This is critical, so we return an error
		return nil, errors.New("payment record created but failed to update order payment status: " + err.Error())
	}

	return payment, nil
}

func (u *paymentUsecase) GetPaymentByID(ctx context.Context, id uint) (*models.Payment, error) {
	payment, err := u.paymentRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if payment == nil {
		return nil, ErrPaymentNotFound
	}
	return payment, nil
}

func (u *paymentUsecase) GetPaymentByResourceID(ctx context.Context, resourceID string) (*models.Payment, error) {
	payment, err := u.paymentRepo.GetByResourceID(ctx, resourceID)
	if err != nil {
		return nil, err
	}
	if payment == nil {
		return nil, ErrPaymentNotFound
	}
	return payment, nil
}

func (u *paymentUsecase) GetPaymentsByOrderID(ctx context.Context, orderID uint) ([]*models.Payment, error) {
	return u.paymentRepo.GetByOrderID(ctx, orderID)
}

func (u *paymentUsecase) UpdatePayment(ctx context.Context, payment *models.Payment) error {
	return u.paymentRepo.Update(ctx, payment)
}

